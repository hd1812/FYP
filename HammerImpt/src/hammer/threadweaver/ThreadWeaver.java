package hammer.threadweaver;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.TreeMap;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import com.rits.cloning.Cloner;

import hammer.common.VoidFunctor;
import hammer.confidencemap.ConfidenceMap;
import hammer.core.Core;
import hammer.core.Core.RankedWeaver;
import hammer.exception.HammerException;
import hammer.forwardmodel.ForwardModel;
import hammer.forwardmodel.SimpleForwardModel;
import hammer.inversemodel.InverseModel;
import hammer.inversemodel.SimpleInverseModel;
import hammer.signals.Signals;
import hammer.state.State;

/**
 * @author hao This class implements and runs the thread to operate hammer
 *         structure
 */
public class ThreadWeaver
{

	public InverseModel	inverseModel_	= new InverseModel();
	public ForwardModel	forwardModel_	= new ForwardModel();

	private String			name_;
	private Double			confidence_;
	private State			currentState_;
	private State			targetState_;
	private ConfidenceMap	currentConfidences_;
	private Signals			signals_;
	private State			predState_;
	private boolean			executing_;
	private boolean			newData_;
	private Core			core_;//The core this thread is registered at
	private Cloner			cloner	= new Cloner();
	public 	String 			imName_;
	public BufferedWriter 	out = null;
	public TreeMap<String,RankedWeaver> sortedweavers_;
	
	VoidFunctor	callback_;
	VoidFunctor readyCallback_;
	threadRun	thread_;

	// Lock definitions
	Lock			criticalLock	= new ReentrantLock();
	final Condition	condition_		= criticalLock.newCondition();

	/**
	 * Constructor,initialise thread with inverse and forward model names, and
	 * some state indication variables
	 * 
	 * @param inverseModel
	 * @param forwardModel
	 */
	public ThreadWeaver(InverseModel inverseModel, ForwardModel forwardModel, Core core, TreeMap<String,RankedWeaver> sw)
	{
		this.inverseModel_ = inverseModel;
		this.forwardModel_ = forwardModel;
		this.core_=core;
		this.imName_=inverseModel.getName();
		name_=inverseModel.getName()+"_"+forwardModel.getName();
		confidence_ = (double) 0;
		executing_ = true;
		newData_ = false;
		predState_=new State();
		signals_=new Signals();
		inverseModel_.getSubcriptions();
		thread_ = new threadRun();
		this.sortedweavers_=sw;
		Thread t = new Thread(thread_);
		t.start();
	}

	/**
	 * It creates an instance of thread using inverse and forward model
	 * 
	 * @param inverseModel
	 * @param forwardModel
	 * @return
	 */
	public static ThreadWeaver make(final InverseModel inverseModel, final ForwardModel forwardModel, final Core core, final TreeMap<String,RankedWeaver> sortedweavers)
	{
		return new ThreadWeaver(inverseModel, forwardModel,core,sortedweavers);
	}

	/**
	 * Register function into a local callback functor
	 * 
	 * @param callback
	 */
	public void registerCallback(final VoidFunctor callback)
	{
		callback_ = callback;
	}

	
	/**
	 * Register function to indicate this thread is ready to start
	 * @param callback
	 */
	public void registerReadyCallback(final VoidFunctor readyCallback)
	{
		readyCallback_ = readyCallback;
	}
	
	/**
	 * Get the name of inverse model
	 * 
	 * @return
	 */
	public final String getName()
	{
		return name_;
	}

	/**
	 * Get dependencies of inverse model
	 * 
	 * @return
	 */
	public final ArrayList<String> getDependencies()
	{
		return inverseModel_.getDependencies();
	}

	/**
	 * Get confidence level
	 * 
	 * @return
	 */
	public Double getConfidence()
	{
		return confidence_;
	}

	/**
	 * Reset confidence level to zero
	 */
	public void resetConfidence()
	{
		confidence_ = (double) 0;
	}

	/**
	 * Set confidence level
	 * 
	 * @param confidence
	 */
	public void setConfidence(Double confidence)
	{
		confidence_ = confidence;
	}

	/**
	 * Set inputs for thread
	 * 
	 * @param current
	 * @param target
	 * @param confidences
	 */
	public void setInputs(final State current, final State target, final ConfidenceMap confidences)
	{
		criticalLock.lock();
		try
		{
			currentState_ = current;
			targetState_ = target;
			currentConfidences_ = confidences;
			newData_ = true;
			condition_.signal();
		} finally
		{
			criticalLock.unlock();
		}
	}

	
	/**
	 * It returns the signals generated by local inverse modal
	 * @return
	 */
	public Signals getSignal(){
		return signals_;
	}
	
	/**
	 * @author hao Main function to run the thread
	 */
	public class threadRun implements Runnable
	{
		public void run()
		{
			boolean firstTime = true;
			Double localConfidence = (double) 0;
			Signals localSignals = new Signals();
			State localCurrentState = new State();
			State localTargetState = new State();
			State localPredictedState = new State();
			ConfidenceMap localConfidenceMap = new ConfidenceMap();
			VoidFunctor localCallback = new VoidFunctor();
			InverseModel localInverseModel = new SimpleInverseModel();
			ForwardModel localForwardModel = new SimpleForwardModel();
			String aspectString="";
			
			ArrayList<String> subscriptions = inverseModel_.getSubcriptions();

			try
			{

				criticalLock.lock();
				while (executing_)
				{
					//System.out.println(inverseModel_.getName());
					// Indicate this thread is waiting for input
					readyCallback_.Function();
					while (!newData_)
					{
						try
						{
							//System.out.println(inverseModel_.getName() + "  waiting");
							// wait until inputs are set
							condition_.await();
							//System.out.println(inverseModel_.getName() + "  continue");
						} catch (InterruptedException e)
						{
						}
					}
					// Exception Check
					// Assert error if no target state is defined
					if (targetState_ != null)
					{
						assert(currentState_.getTimestamp() == targetState_
								.getTimestamp()) : "ThreadWeaver:current and target timestamps don't match";
					}

					// Assert error is invalid current time stamp is given
					if (!firstTime)
					{
						assert(currentState_.getTimestamp() == localPredictedState
								.getTimestamp()) : "ThreadWeaver: invalid current timestamp";
					}

					// Prepare data for operation
					// Get relevant subset of current state to save resource. Error here, subscriptions is empty sometimes
					localCurrentState = State.subset(currentState_, subscriptions);
					//System.out.println("subscriptions "+subscriptions);
					//System.out.println("currentState_ subscriptions "+currentState_.getAspects());
					//System.out.println("---------------------------------------------------");
					if (targetState_ != null)
					{
						localTargetState = State.subset(targetState_, subscriptions);
					} else
					{
						localTargetState = null;
					}

					// Get current confidence map
					localConfidenceMap = ConfidenceMap.subset(currentConfidences_, inverseModel_.getDependencies());
					localConfidence = confidence_;
					localInverseModel = inverseModel_;
					localForwardModel = forwardModel_;
					localCallback = callback_;

					// Indicate that we've already consumed this piece of data
					newData_ = false;

					// UNLOCK
					criticalLock.unlock();

					// Add local confidence to confidence map
					localConfidenceMap.put(localInverseModel.getName(), localConfidence);
					
					// Mark
					// Run inverse model
					localSignals = localInverseModel.simulate(localCurrentState, localTargetState, localConfidenceMap,sortedweavers_);
					signals_=localSignals;
					
					// Run forward model
					localPredictedState = localForwardModel.predict(localCurrentState, localSignals);
					predState_=localPredictedState;
					
					//debugging
					String filePathString="/home/hao/Data/Temp/Preds/"+name_+".dat";
					File f = new File(filePathString);
					if(!f.exists()){
						f.createNewFile();
					}
					out = new BufferedWriter(new FileWriter(f, true));
					if(predState_.contains("G")&&predState_.get("G")!=null&&!predState_.empty()){
						out.append(predState_.get("G").toString()+"\n");
					}
					out.close();
					
					// Override timestamp
					localPredictedState.setTimestamp(localCurrentState.getTimestamp() + 1);

					// Find aspects string
					for(String s:localSignals.getKeys()){
						if(s.contains("Aspect")){
							aspectString=s;
						}
						//debugging
						//System.out.println("sig out: "+s+"  "+localSignals.get(s));
					}
					
					// Update confidence function
					if (!firstTime && !subscriptions.isEmpty())
					{
						//debugging
						//System.out.println("Calculating confidence");
						//System.out.println(currentState_.contains("GOb4Conf"));
						localConfidence += core_.confidence(localCurrentState, localPredictedState,
								localInverseModel.getName(),name_);

						// debugging
						//System.out.println("local confidence "+localConfidence);
					}
					
					//store previous predicted state to inverse model after updating the confidence level
					//inverseModel_.lastPred_=predState_;
					
					//debugging
					//System.out.println("To eat: " +signals_.get("ToEat") + " insulin:"+signals_.get("Insulin"));
					
					// Lock
					criticalLock.lock();

					// Update confidence
					confidence_ = localConfidence;
					firstTime = false;

					// Unlock
					criticalLock.unlock();

					// Callback if necessary. It tells the core that this thread
					// has finished its work.
					if (localCallback != null)
					{
						localCallback.Function();
					}

					// Lock
					criticalLock.lock();
				}
				
				
			} catch (HammerException | IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			} finally
			{

				//criticalLock.unlock(); // unlock the resource in this scope if
										// exception is caught
			}
		}
	}
	public State getPredState(){
		return predState_;
	}
}
